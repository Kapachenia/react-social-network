{"version":3,"sources":["components/Dialogs/DialogItem/DialogItem.js","components/Dialogs/Message/Message.js","components/Dialogs/AddMessageForm/AddMessageForm.js","components/Dialogs/Dialogs.js","components/Dialogs/Dialogs.module.css","components/Dialogs/DialogItem/DialogItem.module.css","components/Dialogs/Message/Message.module.css","hoc/withAuthRedirect.js","components/Profile/ProfileInfo/ProfileInfo.module.css","components/Profile/MyPosts/Post/Post.module.css","components/Profile/ProfileInfo/ProfileInfoStatus.js","components/Profile/ProfileInfo/ProfileInfoStatusWithHooks.js","components/Profile/ProfileInfo/ProfileInfo.js","components/Profile/MyPosts/Post/Post.js","components/Profile/MyPosts/MyPosts.js","components/Profile/MyPosts/MyPostsContainer.js","components/Profile/Profile.js","components/Profile/ProfileContainer.js"],"names":["DialogItem","props","className","classes","dialog","active","to","id","activeClassName","activeLink","name","Message","messages","message","maxLength20","maxLengthCreator","reduxForm","form","onSubmit","handleSubmit","Field","component","Textarea","placeholder","validate","required","Dialogs","state","dialogsPage","dialogElements","dialogs","map","messagesElements","isAuth","dialogsItems","values","addMessage","newMessageBody","module","exports","mapStateToPropsForRedirect","auth","withAuthRedirect","Component","RedirectComponent","this","React","connect","ProfileStatusWithHooks","useState","editMode","setEditMode","status","setStatus","useEffect","onDoubleClick","onChange","e","currentTarget","value","autoFocus","onBlur","updateStatus","ProfileInfo","profile","profile_ava","src","descriptionBlok","photos","large","Post","item","likesCount","MyPosts","memo","postsElement","posts","reverse","post","postsBlock","AddNewPostFormRedux","addPost","newPostText","maxLength10","MyPostsContainer","profilePage","dispatch","addPostActionCreator","Profile","ProfileContainer","userId","match","params","authorizedUserId","history","push","getUserProfile","getStatus","compose","withRouter"],"mappings":"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","file":"static/js/3.666f681e.chunk.js","sourcesContent":["import React from 'react';\r\nimport classes from './DialogItem.module.css';\r\nimport {NavLink} from \"react-router-dom\";\r\n\r\nconst DialogItem = (props) => {\r\n    return (\r\n        <div className={classes.dialog + ' ' + classes.active}>\r\n            <NavLink to={\"/dialogs/\" + props.id} activeClassName={classes.activeLink}>{props.name}</NavLink>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default DialogItem;","import React from 'react';\r\nimport classes from './Message.module.css'\r\n\r\nconst Message = (props) => {\r\n    return (\r\n        <div className={classes.messages}>{props.message}</div>\r\n    )\r\n}\r\n\r\nexport default Message;","import {maxLengthCreator, required} from \"../../../utils/validators/validators\";\r\nimport {Field, reduxForm} from \"redux-form\";\r\nimport {Textarea} from \"../../../common/FormsControls/FormsConrols\";\r\nimport React from \"react\";\r\n\r\nconst maxLength20 = maxLengthCreator(20)\r\n\r\n// onSubmit - что должно выполниться, если форма засобмитится - специальный метод handleSubmit\r\n// handleSubmit появляется из reduxForm\r\n\r\nconst AddMessageForm = (props) => {\r\n    return (\r\n        <form onSubmit={props.handleSubmit}>\r\n            <div>\r\n                <Field component={Textarea} name={\"newMessageBody\"} placeholder=\"Enter your message\" validate={[required, maxLength20]} />\r\n            </div>\r\n            <div>\r\n                <button>Send</button>\r\n            </div>\r\n        </form>\r\n    )\r\n}\r\n\r\nexport default reduxForm({form: 'dialogAddMessageForm'})(AddMessageForm);","import React from 'react';\r\nimport classes from './Dialogs.module.css'\r\nimport DialogItem from \"./DialogItem/DialogItem\";\r\nimport Message from \"./Message/Message\";\r\nimport {Redirect} from \"react-router-dom\";\r\nimport {Field, reduxForm} from 'redux-form';\r\nimport {Textarea} from \"../../common/FormsControls/FormsConrols\";\r\nimport {maxLengthCreator, required} from \"../../utils/validators/validators\";\r\nimport AddMessageForm from \"./AddMessageForm/AddMessageForm\";\r\n\r\nconst Dialogs = (props) => {\r\n\r\n    let state = props.dialogsPage;\r\n\r\n    let dialogElements = state.dialogs.map(dialog => <DialogItem name={dialog.name} key={dialog.id} id={dialog.id}/>);\r\n\r\n    let messagesElements = state.messages.map(message => <Message message={message.message} key={message.id}/>);\r\n\r\n    // let addMessage = () => {\r\n    //     props.addMessage();\r\n    // }\r\n\r\n    // обработчик события на нажатие на каждый символ\r\n    // let onMessageChange = (e) => {\r\n    //     let text = e.target.value;\r\n    //     // call back пришёл из DialogsContainer\r\n    //     props.updateNewMessageText(text);\r\n    // }\r\n// свойство такое же как name у Field\r\n    let addNewMessage = (values) => {\r\n        // alert(values.newMessageBody);\r\n        // в обработчике вызовем addMessage() и передадим текстовое сообщение values.newMessageBody;\r\n        // addMessage приходит в props в Dialogs из контейнерной компоненты благодоря mapDispatchToProps\r\n        // props.addMessage(values.newMessageBody);\r\n    // alert(values.newMessageBody)\r\n        props.addMessage(values.newMessageBody);\r\n    }\r\n\r\n    if (props.isAuth == false) return <Redirect to={\"/login\"}/>;\r\n    // другая запись с !, если не залогинен - редирект\r\n    if (!props.isAuth) return <Redirect to={\"/login\"}/>;\r\n\r\n    return (\r\n        <div className={classes.dialogs}>\r\n            <div className={classes.dialogsItems}>\r\n                {dialogElements}\r\n            </div>\r\n            <div className={classes.messages}>\r\n                {messagesElements}\r\n{/* onSubmit - когда форма засобмитится вызови addNewMessage */}\r\n            </div>\r\n            <AddMessageForm onSubmit={addNewMessage} />\r\n        </div>\r\n    )\r\n}\r\n\r\n// const maxLength20 = maxLengthCreator(20)\r\n\r\n// onSubmit - что должно выполниться, если форма засобмитится - специальный метод handleSubmit\r\n// handleSubmit появляется из reduxForm\r\n\r\n// вынесли в AddMessageForm\r\n// const AddMessageForm = (props) => {\r\n//     return (\r\n//         <form onSubmit={props.handleSubmit}>\r\n//             <div>\r\n//                 <Field component={Textarea} name={\"newMessageBody\"} placeholder=\"Enter your message\" validate={[required, maxLength20]} />\r\n//             </div>\r\n//             <div>\r\n//                 <button>Send</button>\r\n//             </div>\r\n//         </form>\r\n//     )\r\n// }\r\n//\r\n// const AddMessageFormRedux = reduxForm({form: 'dialogAddMessageForm'})(AddMessageForm);\r\n\r\nexport default Dialogs;","// extracted by mini-css-extract-plugin\nmodule.exports = {\"dialogs\":\"Dialogs_dialogs__4yY8G\",\"dialogsItems\":\"Dialogs_dialogsItems__1QHa5\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"activeLink\":\"DialogItem_activeLink__1xxUg\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"messages\":\"Message_messages__1V6Du\"};","import React from \"react\";\r\nimport {Redirect} from \"react-router-dom\";\r\nimport Dialogs from \"../components/Dialogs/Dialogs\";\r\nimport {connect} from \"react-redux\";\r\n\r\n\r\n// вынесем isAuth из mapStateToProps\r\nlet mapStateToPropsForRedirect = (state) => ({\r\n    // profile: state.profilePage.profile,\r\n    // информация залогинены или нет\r\n    isAuth: state.auth.isAuth\r\n});\r\n\r\n// создадим отдельный класс обертку для каждой целевой компоненты\r\n// withAuthRedirect конектик к store и забирает isAuth\r\n\r\nexport const withAuthRedirect = (Component) => {\r\n    class RedirectComponent extends React.Component {\r\n        render() {\r\n            if (!this.props.isAuth) return <Redirect to=\"/login\"/>\r\n\r\n            return <Component {...this.props} />\r\n        }\r\n    }\r\n    // законектим RedirectComponent\r\n\r\n\r\n// добавим ещё один connect. Конектим RedirectComponent, компонету, созданную внутри hoc к store\r\n    let ConnectedAuthRedirectComponent = connect(mapStateToPropsForRedirect)(RedirectComponent);\r\n    // когда вызываем hoc withAuthRedirect возвращается две контейнерные компоненты одна в одной\r\n    return ConnectedAuthRedirectComponent;\r\n}\r\n\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"profile_ava\":\"ProfileInfo_profile_ava__1SLBz\",\"descriptionBlok\":\"ProfileInfo_descriptionBlok__FVJ_i\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"item\":\"Post_item__3Bjfk\"};","import React from 'react';\r\n\r\n// class нужны для создания однопитных объектов. Когда React видит, что пытаются отрисовать\r\n// классовую компоненту, React создаёт объект для этой классовой компоненты. Объект хранится в памяти.\r\n// По этому в классовой компоненте есть свой локальный state, а в функциональной компоненте его нет.\r\n\r\n// переделаем классовую компоненту в функциональную ProfileStatusWithHooks с помощью hook\r\nclass ProfileStatus extends React.Component {\r\n\r\n    state = {\r\n        editMode: false,\r\n        // status, локальный state возми своё начальное значение из приходящих props\r\n        // из props взялся статус и засетался в state\r\n        status: this.props.status\r\n    }\r\n\r\n    // в функциональной компоненте мы создаём функцию, в классовой компонете - метод\r\n\r\n    activateEditMode = () => {\r\n        // setState() метод из React.Component. В this.setState() мы должны передать объект,\r\n        // свойство которого перезапишут те свойство, которые были в state\r\n        // console.log(this.state.editMode);\r\n        // console.log(\"this:\", this);\r\n        this.setState({\r\n            // меняем EditMode на true\r\n            editMode: true\r\n        });\r\n        // console.log(this.state.editMode);\r\n    }\r\n\r\n    // setState асинхронен. Не моментально поменяет state, а когда будет очередной цикл асинхронного запуска\r\n\r\n    deactivateEditMode = () => {\r\n        this.setState({\r\n            editMode: false\r\n        });\r\n        this.props.updateStatus(this.state.status);\r\n    }\r\n\r\n    onStatusChange = (e) => {\r\n        // можем узнать новое значение и засетать в качестве стуса локального state\r\n        // в state меняем только status, по этому в setState мы передаём объект со свойством status\r\n        // новое его значение e.currentTarget.value;\r\n        this.setState({\r\n            status: e.currentTarget.value\r\n        });\r\n\r\n    }\r\n\r\n    // коспонета перерисовывается извне и новые props внедряются либо компонента перерисовывается, когда меняется локальный state\r\n    componentDidUpdate(prevProps, prevState) {\r\n        // если в предыдущих props статус был такой, который не равен статусу в текущих props\r\n        if (prevProps.status !== this.props.status) {\r\n            this.setState({\r\n                status: this.props.status\r\n            })\r\n        }\r\n        // console.log(\"componentDidUpdate\")\r\n    }\r\n\r\n    render() {\r\n        console.log(\"render\")\r\n        return (\r\n            <div>\r\n                {/*если не editMode - покажи span, если editMode - покажи input*/}\r\n                {!this.state.editMode &&\r\n                <div>\r\n                    {/*отображает то что приходит в props. В span и */}\r\n                    <span onDoubleClick={this.activateEditMode}>{this.props.status || \"------\"}</span>\r\n                </div>\r\n                }\r\n                {this.state.editMode &&\r\n                <div>\r\n                    {/*статус берём из локального state*/}\r\n                    {/*если value зафиксировану необходимо вешать onChange*/}\r\n                    <input onChange={this.onStatusChange} autoFocus={true} onBlur={this.deactivateEditMode}\r\n                           value={this.state.status}/>\r\n                </div>\r\n                }\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default ProfileStatus;","import React, {useEffect, useState} from 'react';\r\n\r\n// class нужны для создания однопитных объектов. Когда React видит, что пытаются отрисовать\r\n// классовую компоненту, React создаёт объект для этой классовой компоненты. Объект хранится в памяти.\r\n// По этому в классовой компоненте есть свой локальный state, а в функциональной компоненте его нет.\r\n\r\nconst ProfileStatusWithHooks = (props) => {\r\n    // useState функция, возвращает массив из двух элементов начальное значение делаем false,\r\n    // оно будет первым элементом. Вторым элементом будет функция, которая будет изменять первое значение\r\n    // let stateWithSetState = useState(true);\r\n    // от editMode зависит показывание разметки\r\n    // let editMode = stateWithSetState[0];\r\n    // let setEditMode = stateWithSetState[1];\r\n    // Деструктуризация массива\r\n    let [editMode, setEditMode] = useState(false);\r\n    let [status, setStatus] = useState(props.status);\r\n\r\n    // useEffect - hook запускает какой-то эффект, функцию после того как всё\r\n    // отрисуется и покажется на экране. useEffect запустится, когда придёт новый status\r\n    useEffect(() => {\r\n        setStatus(props.status);\r\n    }, [props.status] );\r\n\r\n    const activateEditMode = () => {\r\n        setEditMode(true);\r\n    }\r\n\r\n    const deactivateEditMode = () => {\r\n        setEditMode(false)\r\n        props.updateStatus(status);\r\n    }\r\n\r\n    const onStatusChange = (e) => {\r\n        // можем узнать новое значение и засетать в качестве стуса локального state\r\n        // в state меняем только status, по этому в setState мы передаём объект со свойством status\r\n        // новое его значение e.currentTarget.value;\r\n        setStatus(e.currentTarget.value);\r\n    }\r\n\r\n    return (\r\n        <div>\r\n            {/*если не editMode - покажи span, если editMode - покажи input*/}\r\n            {/*{!this.state.editMode &&*/}\r\n            {/*если не editMode показывай div*/}\r\n            { !editMode &&\r\n            <div>\r\n                {/*отображает то что приходит в props. В span и */}\r\n                {/*при double click на span переключать локальный статус с false на true*/}\r\n                {/*что бы показался input вместо span*/}\r\n                <span onDoubleClick={ activateEditMode }>{props.status || \"------\"}</span>\r\n            </div>\r\n            }\r\n            {/*{this.state.editMode &&*/}\r\n            {/*если editMode показывай div*/}\r\n            { editMode &&\r\n            <div>\r\n                {/*статус берём из локального state*/}\r\n                {/*если value зафиксировану необходимо вешать onChange*/}\r\n                <input onChange={ onStatusChange } autoFocus={true}\r\n                       onBlur={ deactivateEditMode } value={ status } />\r\n            </div>\r\n            }\r\n        </div>\r\n    )\r\n}\r\n\r\n\r\nexport default ProfileStatusWithHooks;","import React from 'react';\r\nimport classes from './ProfileInfo.module.css';\r\nimport Preloader from \"../../../common/Preloader/Proloader\";\r\nimport ProfileStatus from \"./ProfileInfoStatus\"\r\nimport ProfileStatusWithHooks from \"./ProfileInfoStatusWithHooks\";\r\n\r\nconst ProfileInfo = ({profile, status, updateStatus}) => {\r\n    // показывает preloader, если profile нет. profile загружен контейнерной компонентой Profile\r\n    if (!profile) {\r\n        return <Preloader/>\r\n    }\r\n    return (\r\n        <div>\r\n            <div className={classes.profile_ava}>\r\n                <img src='https://montegrappa.com.ua/wp-content/uploads/2019/03/Samurai-Banner-1200x400.png'></img>\r\n            </div>\r\n            <div className={classes.descriptionBlok}>\r\n                {/*src достанем из профиля*/}\r\n                {/*когда показыем profile статус есть и props и state синхронизированы*/}\r\n                <img src={profile.photos.large}/>\r\n                <ProfileStatusWithHooks status={status} updateStatus={updateStatus} />\r\n\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default ProfileInfo;","import React from 'react';\r\nimport classes from './Post.module.css';\r\n\r\nconst Post = (props) => {\r\n\r\n    return (\r\n        <div className={classes.item}>\r\n            <img src='https://st2.depositphotos.com/1981013/7098/v/600/depositphotos_70983973-stock-illustration-samurai-man.jpg'></img>\r\n            { props.message }\r\n            <div>\r\n                <span>like</span> { props.likesCount }\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Post;","import React, {Component, PureComponent} from 'react';\r\nimport classes from './MyPosts.module.css';\r\nimport Post from \"./Post/Post\";\r\nimport {Field, reduxForm} from \"redux-form\";\r\nimport {required, maxLengthCreator} from \"../../../utils/validators/validators\";\r\nimport {Textarea} from \"../../../common/FormsControls/FormsConrols\";\r\n\r\n// для оптимизации в классовой компоненте используем shouldComponentUpdate, принимает\r\n// два параметра nextProps, nexState\r\n// делаем extends от PureComponent и убираем shouldComponentUpdate\r\n\r\n// для оптимизации функциональной компоненты используем React.memo\r\n// оборачиваем стрелочную функцию React.memo что бы она лишний раз не вызывала render\r\n// На входе одна компонента, а на выходе другая\r\n\r\nconst MyPosts = React.memo ((props) => {\r\n\r\n    // shouldComponentUpdate - нужно ли обновить классовую компоненту\r\n    // shouldComponentUpdate(nextProps, nextState) {\r\n        // сравниваем nextProps с текущими props и state\r\n        // PureComponent - это коспонент, который делает проверку за нас\r\n        // return nextProps != this.props || nextState != this.state;\r\n    // }\r\n\r\n\r\n        // console.log(\"RENDER\");\r\n        let newPostElement = React.createRef();\r\n// сделать копию массива [...props.posts] и её менять\r\n        let postsElement = [...props.posts].reverse().map(post => <Post message={post.message} likesCount={post.likesCount}\r\n                                                         key={post.id}/>)\r\n\r\n        let onAddPost = (values) => {\r\n            props.addPost(values.newPostText);\r\n        }\r\n\r\n        // на каждое нажатие обновление\r\n        // let onPostChange = () => {\r\n        //     let text = newPostElement.current.value;\r\n        //     props.updateNewPostText(text);\r\n        // }\r\n\r\n        return (\r\n            <div className={classes.postsBlock}>\r\n                <h3>my posts</h3>\r\n                {/*когда форма соберёт данные и в форме будет сабмит, форма вызовет наш call back, который мы ей передадим*/}\r\n                <AddNewPostFormRedux onSubmit={onAddPost}/>\r\n                <div className={classes.posts}>\r\n                    {postsElement}\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n)\r\n\r\n\r\nconst maxLength10 = maxLengthCreator(10)\r\n\r\n// форма засобмитится, вызовется onAddPost к нам придёт value в value будет сидеть addNewPost и мф его можем передать в addPost\r\n// добавляем addPost из контейнерной компоненты\r\nlet AddNewPostForm = (props) => {\r\n    return (\r\n        <form onSubmit={props.handleSubmit}>\r\n            <div>\r\n                {/*вместо textarea отрисуй Textarea*/}\r\n                <Field name={\"newPostText\"} component={Textarea} placeholder={\"Enter your post\"}\r\n                       validate={[required, maxLength10]}/>\r\n            </div>\r\n            <div>\r\n                {/*при нажатии на button сабмит происходит автоматически*/}\r\n                <button>add post</button>\r\n            </div>\r\n        </form>\r\n    )\r\n}\r\n\r\nlet AddNewPostFormRedux = reduxForm({form: \"profileAddNewPostForm\"})(AddNewPostForm);\r\n\r\nexport default MyPosts;","import React from 'react';\r\nimport {addPostActionCreator, updateNewPostTextActionCreator} from \"../../../redux/profile-reducer\";\r\nimport {connect} from \"react-redux\";\r\nimport MyPosts from \"./MyPosts\";\r\n\r\nlet mapStateToProps = (state) => {\r\n    return {\r\n        posts: state.profilePage.posts,\r\n        newPostText: state.profilePage.newPostText\r\n    }\r\n};\r\n\r\nlet mapDispatchToProps = (dispatch) => {\r\n    return {\r\n        // принимает значение поста. newPostText передадим в action creator\r\n        addPost: (newPostText) => {\r\n            dispatch(addPostActionCreator(newPostText));\r\n        },\r\n        // updateNewPostText: (text) => {\r\n        //     let action = updateNewPostTextActionCreator(text);\r\n        //     dispatch(action);\r\n        // }\r\n    }\r\n};\r\n\r\nconst MyPostsContainer = connect(mapStateToProps, mapDispatchToProps)(MyPosts);\r\n\r\nexport default MyPostsContainer;","import React from 'react';\r\nimport ProfileInfo from \"./ProfileInfo/ProfileInfo\";\r\nimport MyPostsContainer from \"./MyPosts/MyPostsContainer\";\r\n\r\nconst Profile = (props) => {\r\n// Profile прокидывает props.profile через props в ProfileInfo. props пришли через ProfileContainer\r\n    return (\r\n        <div>\r\n            <ProfileInfo profile = {props.profile} status={props.status} updateStatus={props.updateStatus} />\r\n            <MyPostsContainer />\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Profile;","import React from 'react';\r\nimport Profile from \"./Profile\";\r\nimport {connect} from \"react-redux\";\r\nimport {getStatus, getUserProfile, updateStatus} from \"../../redux/profile-reducer\";\r\nimport {Redirect, withRouter} from \"react-router-dom\";\r\nimport {withAuthRedirect} from \"../../hoc/withAuthRedirect\";\r\nimport {compose} from \"redux\";\r\n\r\nclass ProfileContainer extends React.Component {\r\n    // Sideeffe делаются в метоже жизненного цикла componentDidMount\r\n    componentDidMount() {\r\n\r\n        let userId = this.props.match.params.userId;\r\n        // если у нас нет userId\r\n        if (!userId) {\r\n        // если вмонтировались и в параметрах ничего нет, покажи авторизированного юзера\r\n            userId = this.props.authorizedUserId;\r\n            // если userId не оказалось после присвоения\r\n            if (!userId) {\r\n                // в props у history есть метод push\r\n                this.props.history.push(\"/login\");\r\n            }\r\n        }\r\n        this.props.getUserProfile(userId);\r\n        // сделаем запрос за статусом и передадим userId статус которого нужно получить\r\n        this.props.getStatus(userId);\r\n        // usersAPI.getProfile(userId)\r\n        // // axios.get(`https://social-network.samuraijs.com/api/1.0/profile/${userId}`)\r\n        // // с servera приходит объект response в нём нужно свойство data\r\n        //     .then(response => {\r\n        //         // весь объекст сэтаем в reduces\r\n        //         this.props.setUserProfile(response.data);\r\n        //         // в props этот объект где-то должен появится, с помощье mapDispatchToProps\r\n        //\r\n        //     })\r\n    }\r\n\r\n    render() {\r\n        // делаем редирект вместо отображения разметки\r\n        // if (this.props.isAuth === false) return <Redirect to=\"/login\" />;\r\n        // другая запись с !, если не залогинен - редирект\r\n        // перенесём редирект в AuthRedirectComponent\r\n        // if (!this.props.isAuth) return <Redirect to=\"/login\" />;\r\n        return (\r\n            // прокидываем статус дальше\r\n            <Profile {...this.props} profile={this.props.profile} status={this.props.status} updateStatus={this.props.updateStatus} />\r\n        )\r\n    }\r\n}\r\n\r\n// создадим контейнерную компонету AuthRedirectComponent над контейнерной компонентой ProfileContainer\r\n// props перекидываем деструктуризацией в целевую компонету\r\n// вызывает hoc с нужным параметром, передав нужную целевую компонету\r\n// let AuthRedirectComponent = withAuthRedirect(ProfileContainer);\r\n\r\n\r\n// над компонентой ProfileContainer делаем ещё одну с помощью connect.\r\n// контейнерная компонента будет взаимодействовать со store\r\n\r\nlet mapStateToProps = (state) => ({\r\n    profile: state.profilePage.profile,\r\n    // информация залогинены или нет\r\n    // isAuth: state.auth.isAuth\r\n    // получить статус из state\r\n    status: state.profilePage.status,\r\n    // возмём id пользователя\r\n    authorizedUserId: state.auth.userId,\r\n    // авторизованы или нет\r\n    isAuth: state.auth.isAuth\r\n});\r\n\r\n// вынесем isAuth из mapStateToProps\r\n// let mapStateToPropsForRedirect = (state) => ({\r\n// profile: state.profilePage.profile,\r\n// информация залогинены или нет\r\n// isAuth: state.auth.isAuth\r\n// });\r\n\r\n// добавим ещё один connect\r\n// AuthRedirectComponent = connect(mapStateToPropsForRedirect)(AuthRedirectComponent);\r\n\r\n// withRouter венет новую компоненту,к оторая отрисует ProfileContainer, но закинутся данные из URL\r\n// подключаем к роутору AuthRedirectComponent вместо ProfileContainer\r\n// let WithUrlDataContainerComponent = withRouter(AuthRedirectComponent);\r\n\r\n// ProfileContainer оборачиваем ещё раз функцией connect\r\n// connect получает данные от store и получает call back от store\r\n\r\n// выполним последовательный вызов compose\r\nexport default compose(\r\n    connect(mapStateToProps, {getUserProfile, getStatus, updateStatus}),\r\n    withRouter,\r\n    // withAuthRedirect,\r\n)(ProfileContainer);\r\n\r\n// connect возвращает новую компоненту, которая отрисует ProfileContainer, но закинет данные из store\r\n// поменяем ProfileContainer на WithUrlDataContainerComponent\r\n// export default connect(mapStateToProps, {getUserProfile})(WithUrlDataContainerComponent);\r\n"],"sourceRoot":""}